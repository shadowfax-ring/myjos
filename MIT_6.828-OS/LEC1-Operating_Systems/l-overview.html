<title>L1</title>
<html>
<head>
</head>
<body>

<h1>O/S overview</h1>

<h2>Overview</h2>

<ul>
<li>6.828 goals:

<ul>
<li>Understand operating systems in detail by designing and
implementing a small O/S
<li>Hands-on experience with building systems  ("Applying 6.033")
</ul>

<li>What do applications want from an O/S?
<ul>
<li>Abstract the hardware for convenience and portability
<li>Multiplex the hardware among multiple applications
<li>Isolate applications to contain bugs
<li>Allow sharing among applications
</ul>

<li>How is an O/S built?
<ul>
<li>e.g. OSX, Windows, Linux
<li>the small view: a h/w management library
<li>the big view: physical machine -> abstract one w/ better properties
<li>layer picture:
<ul>
<li>h/w: CPU, mem, disk
<li>kernel: [various services]
<li>user: applications, e.g. vi and gcc
</ul>
<li>we care a lot about the interfaces and internel kernel structure
</ul>

<li>what services does an O/S kernel typically provide?
<ul>
<li>processes
<li>memory
<li>file contents
<li>directories and file names
<li>security
<li>many others: users, IPC, network, time, terminals
</ul>

<li>What does an O/S abstraction look like?
<ul>
<li>Applications only see them via system calls
<li>Examples, from UNIX / Linux:
<li><code>fd = open("out", 1);</code>
<li><code>write(fd, "hello\n", 6);</code>
<li><code>pid = fork();</code>
</ul>

<li>Why is O/S design/implementation hard/interesting?
<ul>
<li>the environment is unforgiving: weird h/w, no debugger
<li>it must be efficient (thus low-level?)
<li>...but abstract/portable (thus high-level?)
<li>powerful (thus many features?)
<li>...but simple (thus a few composable building blocks?)
<li>features interact: <code>fd = open(); ...; fork();</code>
<li>behaviors interact: CPU priority vs memory allocator.
<li>open problems: security, multi-core
</ul>

<li>You'll be glad you learned about operating systems if you...
<ul>
<li>want to work on the above problems
<li>care about what's going on under the hood
<li>have to build high-performance systems
<li>need to diagnose bugs or security problems
</ul>

</ul>

<h2>Class structure</h2>

<ul>

<li>http://pdos.lcs.mit.edu/6.828
<li>Lectures
<ul>
<li>basic O/S ideas
<li>extended inspection of xv6, a traditional O/S
<li>a series of recent topics
</ul>

<li>Homework to prepare for each lecture

<li>Lab: JOS, a small O/S for x86 in an exokernel style
<ul>
<li>you build it, six labs, final project of your choice
<li>kernel interface: expose hardware, but protect -- no abstractions!
<li>unprivileged library: fork, exec, pipe, ...
<li>applications: file system, shell, ..
<li>development environment: gcc, qemu
<li>lab 1 is out
</ul>

<li>Code review

<li>Two quizzes
<ul>
<li>mid-term (in class)
<li>final (during exam week)
</ul>

</ul>

<h2>Case study: the shell (simplified)</h2>

<ul>
<li>6.828 is largely about design and implementation of system
call interface. let's start by looking at how programs use that
interface. example: the Unix shell.
<li>the shell is the Unix command UI
<li>the shell is also a programming/scripting language
<li>typically handles login session, runs other processes
<li>look at some simple examples of shell operations, how they
    use different O/S abstractions, and how those abstractions
    fit together.
    See <a href="../readings/ritchie74unix.pdf">Unix paper</a>
    if you are unfamiliar with the shell.
<li>Basic structure:
<pre>
	while (1) {
	    write (1, "$ ", 2);
	    readcmd (cmd, args);   // parse user input
	    if ((pid = fork ()) == 0) {  // child?
		exec (cmd, args, 0);
	    } else if (pid > 0) {   // parent?
		wait (0);   // wait for child to terminate
	    } else {
		perror ("fork");
	    }
	}
</pre>
<li>system calls: read, write, fork, exec, wait.
    conventions: -1 return value signals error,
    error code stored in <code>errno</code>,
    <code>perror</code> prints out a descriptive error
    message based on <code>errno</code>.
<li>what does fork do?
    <br>copies user memory
    <br>copies process kernel state (e.g. user id)
    <br>child gets a different PID
    <br>child state contains parent PID
    <br>returns twice, with different values
<li>what does exec do?
    <br>replaces memory of current process with instrs/data from file
    <br>i.e. runs a file created by compiler/linker
    <br>still the same process, keeps most state (e.g. user id)
<li>what does wait do?
    <br>waits for any child to exit
    <br>what if child exits before parent calls wait?
<li>the fork/exec split looks wasteful, but it turns out to be useful.

<li>Example:
<pre>
	$ ls
</pre>
<li>how does ls know which directory to look at?
    <br>cwd in kernel-maintained process state, copied during fork
<li>how does it know what to do with its output?
<li>I/O: process has file descriptors, numbered starting from 0.
    <br>index into table in process's kernel state
<li>system calls: open, read, write, close

<li>numbering conventions:
<ul>
<li>file descriptor 0 for input (e.g., keyboard).
<pre>
     read (0, buf, bufsize)
</pre>
<li>file descriptor 1 for output (e.g., terminal)
<pre>
     write (1, "hello\n", strlen("hello\n"))
</pre>
<li>file descriptor 2 for error (e.g., terminal)
</ul>
<li>so ls writes output to file descriptor 1
<li>on fork, child inherits open file descriptors from parent (show in
    process diagram).
<li>on exec, process retains file descriptors.

<li>This shell command sends ls's output to the file out:
<pre>
     $ ls > out
</pre>
<li>Q: how could our simple shell implement output redirection?
<li>A: just before exec insert:
<pre>
	close(1);
	creat("out", 0666);   // fd will be 1
</pre>
<p>The kernel always allocates the first free file descriptor, 1 in this case.
    Could use <code>dup2()</code> to clone a file descriptor to a new number.

<li>Good illustration of why it's nice to have separate fork and exec.

<li>Many commands use 0/1 by default, so they work with redirection.
Here's a simplified cat:
<pre>
main(int argc, char *argv[])
{
  int fd, n;
  char buf[512];
  if(argc > 1)
    fd = open(argv[1], 0);
  else
    fd = 0;
  while((n = read(fd, buf, 512)) > 0)
    write(1, buf, n);
  close(fd);
  exit(0);
}
</pre>
<li>system call interface is very simple, just ints and char buffers.
why not have open() return a pointer reference to a kernel file object?

<li>You can run the shell, redirect its stdin/stdout, etc.
<li>I'll run this shell script with <tt>sh < script</tt>:
<pre>
     echo one
     echo two
</pre>
<li>Q: what will this shell command do?
<pre>
     $ sh < script > out
</pre>
<li>the script itself didn't redirect the echo output,
but it did inherit a fd 1 that was redirected to out.
<li>Q: I'll run the following directly; is it the same as above?
<pre>
     echo one > out
     echo two > out
</pre>

<li>The shell lets you redirect any FD:
<pre>
    $ ls script xxx 2> out
</pre>
after creat, insert:
<pre>
	close(2);
	creat("out", 0666);   // fd will be 2
</pre>
But this feature can interact poorly with itself, e.g. if you
want stdout and stderr to go to the same file:
<pre>
    $ ls script xxx > out 2> out
</pre>
why did this turn out badly?
<br>here's a better plan:
<pre>
    $ ls script xxx > out 2>&1
</pre>
<pre>
	close(2);
	dup(1);		       // fd will be 2
</pre>

<li>Linux has a nice representation of a process and its FDs, under /proc/PID/
<ul>
<li>maps: VA range, perms (p=private, s=shared), offset, dev, inode, pathname
<li>fd: symlinks to files pointed to by each fd.
    (what's missing in this representation?)
<li>try  <tt>exec 3>/tmp/xx ; ls -l /proc/$$/fd</tt>
</ul>

<li>one often wants to run a series of programs on some data:
<pre>
	$ sort < in > out
	$ uniq out > out2
	$ wc out2
	$ rm out out2
</pre>
the shell supports this more concisely with "piping" of "filters":
<pre>
        $ sort < in | uniq | wc
</pre>
<li>A pipe is a one-way communication channel.  Here is a simple example:
<pre>
        int fds[2];
        char buf[512];
        int n;

        pipe(fds);
        write(fds[1], "hello", 5);
        n = read(fds[0], buf, sizeof(buf));
        // buf[] now contains 'h', 'e', 'l', 'l', 'o'
</pre>
<li>file descriptors are inherited across <code>fork()</code>, so this also works:
<pre>
        int fds[2];
        char buf[512];
        int n, pid;

        pipe(fds);
        pid = fork();
        if(pid > 0){
          write(fds[1], "hello", 5);
        } else {
          n = read(fds[0], buf, sizeof(buf));
          exit(0);
        }
</pre>
<li>How does the shell implement pipelines (i.e., cmd 1 | cmd 2 |..)?
We want to arrange that the output of cmd 1 is the input of cmd 2.
The way to achieve this goal is to manipulate stdout and stdin.
<li>The shell creates processes for each command in
the pipeline, hooks up their stdin and stdout,
and waits for the last process of the
pipeline to exit.  Here's a sketch of what the shell does,
in the child process of the <code>fork()</code> we already have,
to set up a pipe:
<pre>	    
	    int fds[2];

  	    if (pipe(fds) < 0) panic ("error");
	    if ((pid = fork ()) == 0) {  child (left end of pipe)
	       close (1);
	       dup (fds[1]);   // fds[1] is the write end, ret will be 1
	       close (fds[0]);       // close read end
	       close (fds[1]);       // close fds[1]
	       exec (command1, args1, 0);
	    } else if (pid > 0) {        // parent (right end of pipe)
	       close (0);
	       dup (fds[0]);   // fds[0] is the read end, ret will be 0
	       close (fds[0]);
	       close (fds[1]);       // close write end
	       exec (command2, args2, 0);
	    } else {
	       printf ("Unable to fork\n");
            }
</pre>
<li>Who waits for whom? (draw a tree of processes)
<li>Why close read-end and write-end? ensure that
every process starts with 3 file descriptors, and that
reading from the pipe returns end of file after the first command exits.
<li>Notes about the file descriptor design:
<ul>
  <li>nice interaction with fork
  <li>FDs help make programs more general purpose: don't need special
      cases for files vs console vs pipe
  <li>shell pipelines only work for programs w/ common formats (lines of text)
</ul>
<li>How do you create a background job?
<pre>
        $ sleep 2 &
</pre>
<li>Q: How does the shell implement "&"?
<li>Q: What if a background process exits while sh waits for a foreground process?
</body>



<!--  LocalWords:  Symbian JavaOS VxWorks pSOS IPC rfork min exokernel gcc CE
 -->
<!--  LocalWords:  bochs PalmOS PDA printf args pid perror ls buf
 -->
<!--  LocalWords:  bufsize strlen tmp fd
 -->
